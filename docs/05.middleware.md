# Middleware

Ecewo provides a middleware feature, which looks like Express.js. Let’s see how they work.

## Table of Contents

1. [Route Specific Middleware](#route-specific-middleware)
2. [Global Middleware](#global-middleware)
3. [Middleware Context](#middleware-context)

## Route Specific Middleware

We have `use()` macro to define route-specific middlewares.

```c
#include "ecewo.h"

int admin_only(Req *req, Res *res, Chain *chain)
{
    // Check if user is admin
    const char *role = get_header(req, "X-User-Role");

    if (!role || strcmp(role, "admin") != 0) {
        send_text(res, 403, "Admin access required");
        return 0; // Stop chain
    }
    
    // Continue to next middleware/handler
    return next(req, res, chain);
}

int validate_settings(Req *req, Res *res, Chain *chain)
{
    // Some validation process...
    // Continue to next middleware/handler
    return next(req, res, chain);
}

int main(void)
{
    // Server setup...

    // Apply middleware to specific route
    get("/admin/users", use(admin_only), admin_users_handler);
    post("/admin/settings", use(admin_only, validate_settings), update_settings);
    
    // ... rest of setup
}

```

## Global Middleware

We have `hook()` to define global middlewares. Let’s implement a simple logger in middlewares.c and apply it before every handler.

```c
#include "ecewo.h"
#include "stdio.h" // for printf

int auth_middleware(Req *req, Res *res, Chain *chain)
{
    const char *auth = get_header(req, "Authorization");
    
    if (!auth || strncmp(auth, "Bearer ", 7) != 0) {
        send_text(res, 401, "Unauthorized");
        return 0; // Stop the chain
    }
    
    // Continue to next middleware/handler
    return next(req, res, chain);
}

int logging_middleware(Req *req, Res *res, Chain *chain)
{
    printf("%s %s\n", req->method, req->path);
    return next(req, res, chain);
}

int main(void)
{
    // Server setup ...

    // Apply to all routes
    hook(logging_middleware);
    hook(auth_middleware);
    
    get("/protected", protected_handler);
    // ... rest of setup
}
```

## Middleware Context

There is a specific way to pass the data along the middleware chain: `get_context()` and `set_context()` functions. We can pass the data to the next middleware or to the handler using them.

```c
typedef struct {
    char *user_id;
    char *role;
} user_ctx_t;

int context_middleware(Req *req, Res *res, Chain *chain)
{
    // Parse JWT token and extract user info
    const char *token = get_header(req, "Authorization");
    
    // Create user context to pass the data
    user_ctx_t *ctx = ecewo_alloc(req, sizeof(user_ctx_t));

    // Copy fields into the context
    ctx->user_id = ecewo_strdup(req, "user123");
    ctx->role = ecewo_strdup(req, "admin");
    
    // Store context in request
    set_context(req, "user_ctx", ctx, sizeof(user_ctx_t));
    
    // Continue
    return next(req, res, chain);
}

void protected_handler(Req *req, Res *res)
{
    user_ctx_t *ctx = (user_ctx_t *)get_context(req, "user_ctx");

    if (strcmp(ctx->user_id, "user123") != 0 ||
        strcmp(ctx->role, "admin") != 0)
    {
        send_text(res, FORBIDDEN, "Forbidden");
        return;
    }
    
    send_text(res, 200, "Success!");
}
```

> [!NOTE]
>
> Ecewo uses arena allocator. So `ecewo_alloc()` and `ecewo_strdup()` macros are parts of it. See the [next chapter](docs/06.memory_management.md).
