# Middleware

ecewo provides a middleware feature, which looks like Express.js. Let’s see how they work.

## Table of Contents

1. [Route Specific Middleware](#route-specific-middleware)
2. [Global Middleware](#global-middleware)
3. [Middleware Context](#middleware-context)

## Route Specific Middleware

```c
#include "ecewo.h"

void admin_only(Req *req, Res *res, Next next) {
  const char *role = get_header(req, "X-User-Role");

  if (!role || strcmp(role, "admin") != 0) {
    send_text(res, 403, "Admin access required");
    return;
  }
  
  // Continue to next middleware/handler
  next(req, res);
}

void validate_settings(Req *req, Res *res, Next next) {
  // Some validation process...
  // Continue to next middleware/handler
  next(req, res);
}

int main(void) {
  // Server setup...

  // Apply middleware to specific route
  get("/admin/users", admin_only, users_handler);
  post("/admin/settings", admin_only, validate_settings, settings_handler);
  
  // ... rest of setup
}
```

A request timeout example:

```c
void custom_timeout_middleware(Req *req, Res *res, Next next) {
  const char *path = req->path;
  
  // Different timeouts for different routes
  if (strncmp(path, "/api/", 5) == 0) {
    request_timeout(res, 10000);  // 10s
  } else if (strncmp(path, "/upload", 7) == 0) {
    request_timeout(res, 300000); // 5min
  }
  // else: no timeout
  
  next(req, res);
}

int main() {
  server_init();

  get("/path", custom_timeout_middleware, handler);

  server_listen(3000);
  server_run();
}
```

## Global Middleware

We have `use()` to define global middlewares. Let’s implement a simple logger in middlewares.c and apply it before every handler.

```c
#include "ecewo.h"
#include "stdio.h"

void auth_middleware(Req *req, Res *res, Next next) {
  const char *auth = get_header(req, "Authorization");
  
  if (!auth || strncmp(auth, "Bearer ", 7) != 0) {
    send_text(res, 401, "Unauthorized");
    return;
  }
  
  // Continue to next middleware/handler
  next(req, res);
}

void logging_middleware(Req *req, Res *res, Next next) {
  printf("%s %s\n", req->method, req->path);
  next(req, res);
}

int main(void) {
  // Server setup ...

  // Apply to all routes
  use(logging_middleware);
  use(auth_middleware);
  
  get("/protected", protected_handler);
  // ... rest of setup
}
```

A global request timeout example:

```c
void timeout_middleware(Req *req, Res *res, Next next) {
  request_timeout(res, 15000);
  next(req, res);
}

int main() {
  server_init();

  use(timeout_middleware);

  get("/path1", handler1);
  get("/path2", handler2);
  get("/path3", handler3);

  server_listen(3000);
  server_run();
}
```

## Middleware Context

There is a specific way to pass the data along the middleware chain: `get_context()` and `set_context()` functions. We can pass the data to the next middleware or to the handler using them.

```c
typedef struct {
  char *user_id;
  char *role;
} user_ctx_t;

void context_middleware(Req *req, Res *res, Next next) {
  const char *token = get_header(req, "Authorization");
  
  // Allocate context from request arena
  user_ctx_t *ctx = arena_alloc(req->arena, sizeof(user_ctx_t));
  ctx->user_id = arena_strdup(req->arena, "user123");
  ctx->role = arena_strdup(req->arena, "admin");
  
  // Store context pointer in request
  set_context(req, "user_ctx", ctx);
  
  // Continue to next middleware
  next(req, res);
}

void protected_handler(Req *req, Res *res) {
  // Retrieve context from request
  user_ctx_t *ctx = (user_ctx_t *)get_context(req, "user_ctx");
  
  if (!ctx) {
    send_text(res, UNAUTHORIZED, "Unauthorized");
    return;
  }
  
  if (strcmp(ctx->user_id, "user123") != 0 ||
    strcmp(ctx->role, "admin") != 0) {
    send_text(res, FORBIDDEN, "Forbidden");
    return;
  }
  
  send_text(res, OK, "Success!");
}
```

### Important Notes

**Context Lifecycle:**
- Context data is stored in the request arena
- Automatically cleaned up after response is sent
- Valid throughout the entire middleware chain and handler

**Memory Management:**
- Always allocate context data from `req->arena`
- `set_context()` stores the pointer directly (no copy)
- All middleware and handlers share the same pointer

> [!NOTE]
>
> ecewo has its own arena allocator. So `arena_alloc()` and `arena_strdup()` functions are parts of it. See the [next chapter](docs/06.memory-management.md).
