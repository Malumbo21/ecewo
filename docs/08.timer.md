# Timers

ecewo provides JavaScript-like `set_timeout()` and `set_interval()` functions, implemented with the libuv event loop, for non-blocking time-based operations.

## Table of Contents
1. [One-time Delay](#one-time-delay)
2. [Periodic Tasks](#periodic-tasks)
3. [Timer Cancellation](#timer-cancellation)
4. [Common Patterns](#common-patterns)

## One-time Delay

The `set_timeout()` function executes a callback function once after a specified delay.

**Signature:**
```c
Timer *set_timeout(timer_callback_t callback, uint64_t delay_ms, void *user_data);
```

**Parameters:**

- `callback`: The callback function to execute
- `delay_ms`: Delay time in milliseconds
- `user_data`: User data to pass to callback (can be NULL)

**Return Value:**

- Success: Timer handle (`Timer*`)
- Failure: `NULL`

### Simple Usage

```c
void show_welcome_notification(void *user_data) {
  char *username = (char*)user_data;
  printf("Welcome %s! Thanks for joining us!\n", username);
  // Send notification to user's browser
}

// After user registration
void on_user_register(const char *username) {
  char *name_copy = strdup(username);
  set_timeout(show_welcome_notification, 2000, name_copy);
  // Timer auto-cleans after 2 seconds
}
```

### Advanced Usage

```c
// Session Timeout System

typedef struct {
  int user_id;
  Timer *warning_timer;
  Timer *expiry_timer;
} session_timers_t;

void warn_session_expiring(void *user_data) {
  int user_id = *(int*)user_data;
  printf("Warning: Session for user %d expires in 5 minutes!\n", user_id);
  send_session_warning(user_id);
  free(user_data);
  // Timer auto-cleans
}

void expire_user_session(void *user_data) {
  session_timers_t *timers = (session_timers_t*)user_data;
  printf("Session expired for user %d\n", timers->user_id);
  logout_user(timers->user_id);
  free(timers);
  // Timer auto-cleans
}

// Set up session timeouts when user logs in
session_timers_t* setup_session_timeout(int user_id) {
  session_timers_t *timers = malloc(sizeof(session_timers_t));
  timers->user_id = user_id;
  
  // Warn 5 minutes before expiry (25 minutes)
  int *uid = malloc(sizeof(int));
  *uid = user_id;
  timers->warning_timer = set_timeout(warn_session_expiring, 25 * 60 * 1000, uid);
  
  // Expire after 30 minutes
  timers->expiry_timer = set_timeout(expire_user_session, 30 * 60 * 1000, timers);
  
  return timers; // Return so caller can cancel if needed
}

// Cancel session timeout (e.g., when user logs out early)
void cancel_session_timeout(session_timers_t *timers) {
  if (timers->warning_timer) {
    clear_timer(timers->warning_timer);
    timers->warning_timer = NULL;
  }

  if (timers->expiry_timer) {
    clear_timer(timers->expiry_timer);
    // Don't free timers here - expiry callback won't be called
    free(timers);
  }
}
```

## Periodic Tasks

The `set_interval()` function executes a callback function repeatedly at specified intervals.

**Signature:**
```c
Timer *set_interval(timer_callback_t callback, uint64_t interval_ms, void *user_data);
```

**Parameters:**

- `callback`: The callback function to execute
- `interval_ms`: Repeat interval in milliseconds
- `user_data`: User data to pass to callback (can be NULL)

**Return Value:**

- Success: Timer handle (`Timer*`)
- Failure: `NULL`

**Important:** For `set_interval`, you **MUST call `clear_timer()`** to stop the timer. Otherwise, it runs forever (until server shutdown).

### Simple Usage

```c
void print_current_time(void *user_data) {
  (void)user_data;
  time_t now = time(NULL);
  printf("Current time: %s", ctime(&now));
}

// Print time every 10 seconds
Timer *start_time_display(void) {
  return set_interval(print_current_time, 10000, NULL);
}

// Stop the timer
void stop_time_display(Timer *timer) {
  clear_timer(timer);
}
```

### Advanced Usage

```c
// Auto-Save System

typedef struct {
  int user_id;
  char *document_id;
  Timer *auto_save_timer;
} auto_save_context_t;

void auto_save_document(void *user_data) {
  auto_save_context_t *ctx = (auto_save_context_t*)user_data;
  
  printf("Auto-saving document %s for user %d...\n", 
         ctx->document_id, ctx->user_id);
  
  // Save to database
  if (save_to_database(ctx->user_id, ctx->document_id)) {
    printf("Document saved successfully!\n");
  } else {
    printf("Save failed - will retry in 30s\n");
  }
}

// Start auto-save (every 30 seconds)
auto_save_context_t* start_auto_save(int user_id, const char *doc_id) {
  auto_save_context_t *ctx = malloc(sizeof(auto_save_context_t));
  ctx->user_id = user_id;
  ctx->document_id = strdup(doc_id);
  ctx->auto_save_timer = set_interval(auto_save_document, 30000, ctx);
  
  if (!ctx->auto_save_timer) {
    free(ctx->document_id);
    free(ctx);
    return NULL;
  }
  
  return ctx;
}

// Stop auto-save (when user closes document)
void stop_auto_save(auto_save_context_t *ctx) {
  if (ctx) {
    if (ctx->auto_save_timer) {
      clear_timer(ctx->auto_save_timer);
      ctx->auto_save_timer = NULL;
    }
    free(ctx->document_id);
    free(ctx);
  }
}
```

## Timer Cancellation

The `clear_timer()` function cancels a pending or active timer.

**Signature:**
```c
void clear_timer(Timer *timer);
```

**Parameters:**

- `timer`: Timer handle to cancel (from `set_timeout` or `set_interval`)

**When to Use:**

- **Always** for `set_interval` timers (to stop repetition)
- For `set_timeout` timers **only if cancelling before they fire**
- **Never** for `set_timeout` timers after they've already fired (auto-cleaned)

### Simple Usage

```c
Timer *hello_timer = NULL;

void say_hello(void *user_data) {
  (void)user_data;
  printf("Hello!\n");
}

void start_hello_timer(void) {
  hello_timer = set_interval(say_hello, 2000, NULL);
  printf("Started saying hello every 2 seconds\n");
}

void stop_hello_timer(void) {
  if (hello_timer) {
    clear_timer(hello_timer);
    hello_timer = NULL;
    printf("Stopped saying hello\n");
  }
}
```

### Advanced Usage

```c
// Email Scheduler with Cancellation

typedef struct {
  char *recipient;
  char *subject;
  char *body;
  Timer *timer;
} email_schedule_t;

void send_email(void *user_data) {
  email_schedule_t *schedule = (email_schedule_t*)user_data;
  
  printf("Sending email to %s: %s\n", schedule->recipient, schedule->subject);
  
  smtp_send(schedule->recipient, schedule->subject, schedule->body);
  
  free(schedule->recipient);
  free(schedule->subject);
  free(schedule->body);
  free(schedule);
  // Timer auto-cleans
}

email_schedule_t* schedule_email(const char *to, const char *subject, 
                                 const char *body, uint64_t delay_ms) {
  email_schedule_t *schedule = malloc(sizeof(email_schedule_t));
  schedule->recipient = strdup(to);
  schedule->subject = strdup(subject);
  schedule->body = strdup(body);
  
  schedule->timer = set_timeout(send_email, delay_ms, schedule);
  
  if (!schedule->timer) {
    free(schedule->recipient);
    free(schedule->subject);
    free(schedule->body);
    free(schedule);
    return NULL;
  }
  
  printf("Email scheduled for %s (will send in %llu ms)\n", to, delay_ms);
  return schedule;
}

// Cancel scheduled email
void cancel_email(email_schedule_t *schedule) {
  if (schedule && schedule->timer) {
    clear_timer(schedule->timer);
    
    free(schedule->recipient);
    free(schedule->subject);
    free(schedule->body);
    free(schedule);
    
    printf("Scheduled email cancelled\n");
  }
}
```

> [!NOTE]
>
> For `set_timeout`, you **do NOT need to call `clear_timer()`**. The timer automatically cleans up after executing. Only call `clear_timer()` if you need to cancel before it fires.
>
> If you cancel with `clear_timer()`, **you must free** user_data yourself

```c
// Normal execution
char *data = strdup("hello");
set_timeout(callback, 1000, data);
// callback will free(data)

// Cancelled execution
char *data = strdup("hello");
Timer *timer = set_timeout(callback, 1000, data);
clear_timer(timer);
free(data); // Must free since callback won't run
```

## Common Patterns

### Health Check

```c
typedef struct {
  const char *service_name;
  const char *endpoint;
} health_check_t;

void check_service_health(void *user_data) {
  health_check_t *check = (health_check_t*)user_data;
  
  if (ping_service(check->endpoint)) {
    printf("%s is healthy\n", check->service_name);
  } else {
    printf("%s is DOWN!\n", check->service_name);
    send_alert(check->service_name);
  }
}

int main() {
  server_init();
  
  // Check database health every 30 seconds
  static health_check_t db_check = {
    .service_name = "Database",
    .endpoint = "localhost:5432"
  };
  set_interval(check_service_health, 30000, &db_check);
  
  server_listen(3000);
  server_run();
}
```

### Rate Limiter Reset

```c
typedef struct {
  int user_id;
  int request_count;
} rate_limit_t;

void reset_rate_limit(void *user_data) {
  rate_limit_t *limit = (rate_limit_t*)user_data;
  limit->request_count = 0;
  printf("Rate limit reset for user %d\n", limit->user_id);
  free(limit);
}

void handle_request(int user_id) {
  rate_limit_t *limit = get_rate_limit(user_id);
  limit->request_count++;
  
  if (limit->request_count == 1) {
    // First request - schedule reset in 1 minute
    rate_limit_t *limit_copy = malloc(sizeof(rate_limit_t));
    *limit_copy = *limit;
    set_timeout(reset_rate_limit, 60000, limit_copy);
  }
}
```
