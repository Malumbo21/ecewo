# Async Operations

Since C doesn’t natively support asynchronous operations, this can be one of the more challenging aspects of working with Ecewo. As a result, async behavior may differ a bit from what you’re used to. We need to write callbacks. Many, callbacks...

## Table of Contents

1. [The Async Logic](#the-async-logic)
2. [Step 1: Create A Context Structure And Declare Functions](#step-1-create-a-context-structure-and-declare-functions)
3. [Step 2: Create An Entry Point](#step-2-create-an-entry-point)
4. [Step 3: Write The First Operation](#step-3-write-the-first-operation)
5. [Step 4: Write The Second Operation](#step-4-write-the-second-operation)
6. [Final View](#final-view)
7. [Test](#test)

## General Purpose Async

Ecewo provides `task()` and `then()` functions, similar to `promise().then()` behavior in JavaScript. These are simplify working with [libuv](https://github.com/libuv/libuv), a native C library designed for asynchronous I/O operations.

`task()` and `then()` functions use libuv’s thread pool to execute tasks in the background. Even though they don't create a new thread for every task, using them for lightweight operations may still introduce context-switching overhead and unnecessary resource usage.

For this reason, it is recommended to use them only for **heavy or long-running operations** — such as CPU-bound operations like processing large files or making external API calls that involve network latency or blocking behavior.

For asynchronous database queries, see the [Async Postgres Queries](docs/examples/async-postgres.md) section.

### The Async Logic

Async operations in Ecewo are implemented as an operation chain. A chain includes:
- One entry point, which is our **handler**,
- One operation that includes at least two functions: A **task function** and a **completion function**,
- One **struct** that includes our context.

Every async handler requires a **task function** that performs the *task* and does the job, and every task function requires a **completion function** to process its result. So, each operation is composed of two primary parts, and these two parts are inseparable and must always be used together.

- The **handler** is the entry point. It receives the `Req *req` and `Res *res` objects and starts the chain by calling only the first **task function** using `task()`.
- The **task function** performs the actual async task. Once it completes, it returns either a success or failure result to the **completion function** using `ok()` or `fail()`.
- The **completion function** processes the result received from the **task function**. It then either sends a response to the client or triggers the next operation in the chain using `then()`.

So, the async logic follows this flow:

For single async operation:

```
handler() -> task() ├─> ok() -> send success
                    └─> fail() -> send error
```

For multiple async operation:

```
handler() -> task() ├─> fail() -> send error
                    └─> ok() -> then() ├─> fail() -> send error
                                       └─> ok() -> then() ├─> fail() -> send error
                                                          └─> ok() -> send success
```

If we imagine that we have 2 async operations in the chain, our `async` process will work as follows:

```c
// Handler, which is our entry point
void handler(Req *req, Res *res){...}        

// 1. work, which is process the task
static void first_work(async_t *task, void *context){...}

// 1. done, which is process the result
// sends a response or continues to the next work
static void first_done(void *context, int success, char *error){...}

// 2. work, which is process the next task
static void second_work(async_t *task, void *context){...}

// 2. done, which is process the result
// sends a response and exit
static void second_done(void *context, int success, char *error){...}
```

The `first_work()` function process the operation, and send the result to the `first_done()` function using `ok()` for success and `fail()` for error.

The `first_done()` function send a response to the client with the result that received from `first_work()`. Or, if the async chain continues, the `first_done()` function calls the `second_work()` function using `then()`.

The `second_done()` function process the next operation just like the first one, and then the `second_done()` function send the latest response to the client.

Let's go through an example to see how the process works.

### Step 1: Create A Context Structure And Declare Functions

```c
#include "ecewo.h"

// Context for chained operations
typedef struct
{
    Res *res;
    long input;
    long intermediate;
    long final;
} ctx_t;

// Forward declarations of our async chain
static void add_work(async_t *task, void *context);
static void add_done(void *context, int success, char *error);
static void multiply_work(async_t *task, void *context);
static void multiply_done(void *context, int success, char *error);
```

We define `Res *res` in the context struct because we use it out of the handler. If we also need `Req *req` out of the handler, we also need to define it in the struct.

### Step 2: Create An Entry Point

An entry point is our usual handler.

```c
// HTTP handler
void calculate(Req *req, Res *res)
{
    // Get the number from request params
    const char *num_str = get_params(req, "num");

    // Convert it to a number
    long num = num_str ? strtol(num_str, NULL, 10) : 0;

    // Allocate memory for async
    ctx_t *ctx = ecewo_alloc(req, sizeof(*ctx)); // allocate in arena
    if (!ctx)
    {
        send_text(res, 500, "Memory allocation failed");
        return;
    }

    ctx->res = res;
    ctx->input = num;
    ctx->intermediate = 0;
    ctx->final = 0;

    // Start the chain: addition
    task(ctx, add_work, add_done);
}
```

The `task(ctx, add_work, add_done)` takes three parameters: First one is the context, second one is the task function, and the third one is the completion function.

### Step 3: Write The First Operation

```c
static void add_work(async_t *task, void *context)
{
    // Assign the context
    ctx_t *ctx = context;

    // Add 10 to the input
    ctx->intermediate = ctx->input + 10;

    // Go to the _done function
    ok(task);
}

static void add_done(void *context, int success, char *error)
{
    if (success)
    {
        then(context, success, error, multiply_work, multiply_done);
        // if success, "then" calls the next task named "multiply"
    }
    else
    {
        // Assign the context
        ctx_t *ctx = context;

        // Send a response
        send_text(ctx->res, 500, error);
    }
}
```

### Step 4: Write The Second Operation

At the previously step, `add_done()` function called the next operation with `then(context, success, error, multiply_work, multiply_done)` if the process is success. So let's write the multiplying operation.

```c
static void multiply_work(async_t *task, void *context)
{
    // Assign the context
    ctx_t *ctx = context;

    // example fail case: intermediate result is too large
    if (ctx->intermediate > 1000)
    {
        // Send an "error" to the "multiply_done()" function
        fail(task, "Intermediate too large to multiply");
    }
    else
    {
        // multiply intermediate result by 5
        ctx->final = ctx->intermediate * 5;

        // Send a "success" to the "multiply_done()" function
        ok(task);
    }
}

static void multiply_done(void *context, int success, char *error)
{
    // Assign the context
    ctx_t *ctx = context;

    // If "multiply_work()" function returns an error
    if (!success)
    {
        send_text(ctx->res, 500, error);
        return;
    }

    char buf[128];
    int len = snprintf(buf, sizeof(buf),
                        "((%ld) + 10) * 5 = %ld",
                        ctx->input, ctx->final);

    send_text(ctx->res, 200, buf);
}
```

### Final View

In the end, the our async operation should look like this:

```c
#include "ecewo.h"

// Context for chained operations
typedef struct
{
    Res *res;
    long input;
    long intermediate;
    long final;
} ctx_t;

// Forward declarations of our async chain
static void add_work(async_t *task, void *context);
static void add_done(void *context, int success, char *error);
static void multiply_work(async_t *task, void *context);
static void multiply_done(void *context, int success, char *error);

// HTTP handler
void calculate(Req *req, Res *res)
{
    // Get the number from request params
    const char *num_str = get_params(req, "num");

    // Convert it to a number
    long num = num_str ? strtol(num_str, NULL, 10) : 0;

    // Allocate memory for async
    ctx_t *ctx = ecewo_alloc(req, sizeof(*ctx)); // allocate in arena
    if (!ctx)
    {
        send_text(res, 500, "Memory allocation failed");
        return;
    }

    ctx->res = res;
    ctx->input = num;
    ctx->intermediate = 0;
    ctx->final = 0;

    // Start the chain: addition
    task(ctx, add_work, add_done);
}

static void add_work(async_t *task, void *context)
{
    // Assign the context
    ctx_t *ctx = context;

    // Add 10 to the input
    ctx->intermediate = ctx->input + 10;

    // Go to the _done function
    ok(task);
}

static void add_done(void *context, int success, char *error)
{
    if (success)
    {
        then(context, success, error, multiply_work, multiply_done);
        // if success, "then" calls the next task named "multiply"
    }
    else
    {
        // Assign the context
        ctx_t *ctx = context;

        // Send a response
        send_text(ctx->res, 500, error);
    }
}

static void multiply_work(async_t *task, void *context)
{
    // Assign the context
    ctx_t *ctx = context;

    // example fail case: intermediate result is too large
    if (ctx->intermediate > 1000)
    {
        // Send an "error" to the "multiply_done()" function
        fail(task, "Intermediate too large to multiply");
    }
    else
    {
        // multiply intermediate result by 5
        ctx->final = ctx->intermediate * 5;

        // Send a "success" to the "multiply_done()" function
        ok(task);
    }
}

static void multiply_done(void *context, int success, char *error)
{
    // Assign the context
    ctx_t *ctx = context;

    // If "multiply_work()" function returns an error
    if (!success)
    {
        send_text(ctx->res, 500, error);
        return;
    }

    char buf[128];
    int len = snprintf(buf, sizeof(buf),
                        "((%ld) + 10) * 5 = %ld",
                        ctx->input, ctx->final);

    send_text(ctx->res, 200, buf);
}
```

### Test

Let's run and test our async chain.

```c
get("/calculate/:num", calculate);
```

Register this route in `main` function and compile the program.

```shell
mkdir build && cd build && cmake .. && cmake --build .
chmod +x server
./server
```

Alternatively, if you use [Ecewo-CLI](https://github.com/savashn/ecewo-cli)

```
ecewo build dev
ecewo run
```

Start the server and go to `http://localhost:3000/calculate/100`. We will receive that response:

```
((100) + 10) * 5 = 550
```

If go to `http://localhost:3000/calculate/10000` now and we'll receive:

```
Intermediate too large to multiply
```
