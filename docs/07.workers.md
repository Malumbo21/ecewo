# Workers

Ecewo provides powerful asynchronous capabilities for handling different types of operations efficiently, thanks to [libuv](https://libuv.org/). This guide covers CPU-bound tasks **only**. The I/O-bound operations are shown in the next chapters.

## Table of Contents

1. [Handler-Level Worker](#handler-level-worker)
2. [Task-Level Worker](#task-level-worker)
3. [Summary](#summary)
4. [API Reference](#api-reference)

Blocking computations should not run on the main event loop as they would block all other requests. Ecewo provides two approaches to handle blocking CPU-bound operations safely:

1. **Handler-Level Worker**: Run the entire handler in a worker thread
2. **Task-Level Worker**: Run specific tasks in worker threads while the handler stays on the main thread

The `worker` is for executing blocking operations in a worker thread without blocking the event loop. It runs the provided handler on a thread where blocking is acceptable. The handler will be executed in a worker thread from the libuv's thread pool. It's safe to write blocking code in it, such as heavy computations.

> [!IMPORTANT]
>
> Workers use libuv's thread pool (default: 4 threads). All blocking operations share this pool, so requests may wait if all threads are busy. Set `UV_THREADPOOL_SIZE` environment variable to increase the thread pool size if needed.

## Handler-Level Worker

Handler-level worker runs the **entire handler** in a worker thread. Each request gets one worker thread from libuv's thread pool.

Use this for:
- Sequential blocking operations
- Single blocking task per request
- When the whole handler needs to block

To register a handler-level async route, use the `*_worker()` variants:

| Regular (Event Loop) | Worker Thread    |
|----------------------|------------------|
| `get()`              | `get_worker()`   |
| `post()`             | `post_worker()`  |
| `put()`              | `put_worker()`   |
| `del()`              | `del_worker()`   |
| `patch()`            | `patch_worker()` |

A basic example:

```c
void cpu_bound_handler(Req *req, Res *res)
{
    const char *step1_result = cpu_process_step1(req);
    const char *step2_result = cpu_process_step2(step1_result);
    const char *step3_result = cpu_process_step3(step2_result);
    
    reply(res, OK, step3_result, strlen(step3_result));
}

get("/cpu", cpu_bound_handler); // DO NOT DO THIS!
// This will block the main thread and make the entire
// application wait until the handler responds

get_worker("/cpu", cpu_bound_handler); // DO THIS INSTEAD
// This runs the handler in a worker thread,
// so the main thread is never blocked
```

> [!NOTE]
>
> For fire-and-forget operations, send a response first (it will free the arena memory) and then call the function that will run on the background.

## Task-Level Worker

Runs specific tasks in parallel worker threads while the handler stays on the main thread. Multiple tasks can execute simultaneously.

Use the `worker()` function for this approach.

**When to use:**
- Multiple independent blocking operations
- Operations that can run in parallel
- Need faster response times (parallel execution)

**How it works:**

1. Handler runs on main thread
2. Each task runs in its own worker thread
3. Completion callback runs on main thread when task finishes

Let's see how it works doing an example that runs 3 independent tasks as paralelly.

```c
#include "ecewo.h"
#include <stdio.h>
#include <stdbool.h>

// Context for parallel operations
typedef struct {
    Res *res;

    // Task management
    int total_tasks;
    int completed_tasks;
    bool response_sent;

    // Task results
    const char *task1_result;
    const char *task2_result;
    const char *task3_result;
} ParallelContext;

// ===== TASK FUNCTIONS =====
// These run in worker threads (safe to block)

void task1(Task *task, void *context)
{
    ParallelContext *ctx = (ParallelContext *)context;
    
    // Blocking operation 1 (e.g., heavy computation)
    // This runs in a worker thread, safe to block
    ctx->task1_result = "Task 1 completed";
}

void task2(Task *task, void *context)
{
    ParallelContext *ctx = (ParallelContext *)context;
    
    // Blocking operation 2 (e.g., external API call)
    // This runs in a worker thread, safe to block
    ctx->task2_result = "Task 2 completed";
}

void task3(Task *task, void *context)
{
    ParallelContext *ctx = (ParallelContext *)context;
    
    // Blocking operation 3 (e.g., image processing)
    // This runs in a worker thread, safe to block
    ctx->task3_result = "Task 3 completed";
}

// ===== COMPLETION HANDLER =====
// This runs on the main thread when each task finishes

void completion_cb(void *context, char *error)
{
    ParallelContext *ctx = (ParallelContext *)context;
    
    // Skip if response already sent
    if (ctx->response_sent)
        return;
    
    // Handle system errors (very rare)
    if (error)
    {
        ctx->response_sent = true;
        fprintf(stderr, "System error: %s\n", error);
        send_text(ctx->res, 500, error);
        return;
    }
    
    // Track progress
    ctx->completed_tasks++;
    
    // All tasks finished?
    if (ctx->completed_tasks == ctx->total_tasks)
    {
        // All tasks done - send response
        char *response = ecewo_sprintf(ctx->res,
            "All tasks completed:\n"
            "- Task 1: %s\n"
            "- Task 2: %s\n"
            "- Task 3: %s\n",
            ctx->task1_result,
            ctx->task2_result,
            ctx->task3_result
        );
        
        ctx->response_sent = true;
        send_text(ctx->res, 200, response);
    }
}

// ===== ROUTE HANDLER =====
// This runs on the main thread

void parallel_handler(Req *req, Res *res)
{
    // Create context (arena-allocated)
    ParallelContext *ctx = ecewo_alloc(res, sizeof(ParallelContext));
    ctx->res = res;
    
    // Initialize
    ctx->total_tasks = 3;
    ctx->completed_tasks = 0;
    ctx->response_sent = false;
    ctx->task1_result = NULL;
    ctx->task2_result = NULL;
    ctx->task3_result = NULL;
    
    // Launch 3 parallel tasks
    // Each runs in its own worker thread
    worker(ctx, task1, completion_cb);
    worker(ctx, task2, completion_cb);
    worker(ctx, task3, completion_cb);
    
    // Response NOT sent here!
    // completion_cb sends when all tasks finish
}

// ===== ROUTE REGISTRATION =====

int main(void)
{
    server_init();
    
    // CORRECT: Use regular get()
    get("/parallel", parallel_handler);
    
    // WRONG: Don't use get_worker()
    // get_worker("/parallel", parallel_handler);
    
    server_listen(3000);
    server_run();
    
    return 0;
}
```

> [!IMPORTANT]  
> 
> **Use Regular Routes with `worker()`**
>
> When using `worker()` function for parallel operations, always register routes with regular macros (`get()`, `post()`, etc.), **NOT** `get_worker()`, `post_worker()`, or any other `*_worker()` variants.
>
> The handler itself shouldn't be in a worker thread.

## Summary

In short, the difference between the `*_worker()` router and the `worker()` function is that the `*_worker()` router runs the entire handler in a worker thread, and costs one worker thread per request. It is suitable for sequential workflows or single tasks that will run on a single thread.

In contrast, the `worker()` function runs specific tasks within the handler on worker threads, rather than executing the whole handler on a single worker thread. As a result, it may consume more than one worker thread per request. It is suitable for independent parallel tasks that will run on multiple threads.

**Example comparison:**

```c
// Handler-Level: Sequential (9 minutes, 1 thread)
void sequential_handler(Req *req, Res *res) {
    char *step1 = blocking_op_1();  // 3 minutes
    char *step2 = blocking_op_2();  // 3 minutes  
    char *step3 = blocking_op_3();  // 3 minutes
    send_text(res, 200, step3);
}
get_worker("/sequential", sequential_handler);

// Task-Level: Parallel (3 minutes, 3 threads)
void parallel_handler(Req *req, Res *res) {
    Context *ctx = ecewo_alloc(res, sizeof(Context));
    task(ctx, task_fn_1, callback);  // 3 minutes
    task(ctx, task_fn_2, callback);  // 3 minutes
    task(ctx, task_fn_3, callback);  // 3 minutes
    // All run in parallel
}
get("/parallel", parallel_handler);
```

> [!TIP]
> 
> - For sequential or single CPU-bound operations, use handler-level worker (`get_worker()`, `post_worker()`, etc.)
> - For independent parallel blocking operations, use `worker()` function

## API Reference

### get_worker()

Register `GET` route that runs in worker thread.

```c
void get_worker(const char *path, RequestHandler handler);
```

**Parameters:**

- `path`: Route path (e.g., "/compute")
- `handler`: Handler function to run in worker thread

**Example:**

```c
void heavy_computation(Req *req, Res *res)
{
    // CPU-intensive work here
    int result = compute_fibonacci(40);
    char *response = ecewo_sprintf(res, "Result: %d", result);
    send_text(res, 200, response);
}

get_worker("/compute", heavy_computation);
```

`post_worker()`, `put_worker()`, `del_worker()`, `patch_worker()`
Same as `get_worker()` but for different HTTP methods.

**Example:**

```c
post_worker("/process", process_handler);
put_worker("/update", update_handler);
del_worker("/delete", delete_handler);
patch_worker("/patch", patch_handler);
```

### worker()

Execute a specific task in worker thread.

```c
int worker(void *context, work_handler_t work_fn, result_handler_t result_fn);
```

**Parameters:**

- `context`: User context (must contain arena, usually from req or res)
- `work_fn`: Function to execute in worker thread
- `result_fn`: Callback when work completes (runs on main thread)

**Callback Signatures:**

```c
// Work function (runs in worker thread)
typedef void (*work_handler_t)(Task *task, void *context);

// Result function (runs on main thread)
typedef void (*result_handler_t)(void *context, char *error);
```

**Returns:**

- `0` on success
- `-1` on failure

**Example:**

```c
void heavy_task(Task *task, void *context)
{
    MyContext *ctx = (MyContext *)context;
    // CPU-intensive work (in worker thread)
    ctx->result = compute_something();
}

void task_complete(void *context, char *error)
{
    MyContext *ctx = (MyContext *)context;
    
    if (error)
    {
        send_text(ctx->res, 500, error);
        return;
    }
    
    send_text(ctx->res, 200, ctx->result);
}

void handler(Req *req, Res *res)
{
    MyContext *ctx = ecewo_alloc(res, sizeof(MyContext));
    ctx->res = res;
    
    worker(ctx, heavy_task, task_complete);
}
```
